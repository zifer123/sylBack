{"version":3,"sources":["webpack:///static/js/1.cdfb767fdbf5e02272ef.js","webpack:///./src/pages/index/children/Echart/Bar.vue","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./~/echarts/lib/coord/cartesian/Grid.js","webpack:///Bar.vue","webpack:///./~/echarts/lib/chart/bar.js","webpack:///./~/echarts/lib/chart/bar/BarSeries.js","webpack:///./~/echarts/lib/chart/bar/BarView.js","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js","webpack:///./~/echarts/lib/chart/bar/helper.js","webpack:///./~/echarts/lib/component/axis.js","webpack:///./~/echarts/lib/component/axis/CartesianAxisView.js","webpack:///./~/echarts/lib/component/gridSimple.js","webpack:///./~/echarts/lib/coord/axisDefault.js","webpack:///./~/echarts/lib/coord/axisModelCreator.js","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js","webpack:///./~/echarts/lib/layout/barGrid.js","webpack:///./src/pages/index/children/Echart/Bar.vue?8dbe"],"names":["webpackJsonp","308","module","exports","__webpack_require__","Component","513","getAxisType","axisDim","option","type","data","zrUtil","ComponentModel","axisModelCreator","axisModelCommonMixin","AxisModel","extend","axis","init","superApply","this","arguments","resetRange","mergeOption","restoreData","getCoordSysModel","ecModel","queryComponents","mainType","index","gridIndex","id","gridId","merge","prototype","extraOption","offset","_default","514","isAxisUsedInTheGrid","axisModel","gridModel","rotateTextRect","textRect","rotate","rotateRadians","Math","PI","boundingBox","plain","beforeWidth","width","beforeHeight","height","afterWidth","cos","sin","afterHeight","BoundingRect","x","y","getLabelUnionRect","rect","model","labels","getFormattedLabels","axisLabelModel","getModel","step","labelCount","length","ceil","i","isLabelIgnored","unrotatedSingleRect","getTextRect","singleRect","get","union","Grid","api","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","fixAxisOnZero","axesMap","otherAxisDim","axes","onZero","onZeroAxisIndex","otherAxis","canNotOnZeroToAxis","idx","hasOwnProperty","ifAxisCrossZero","updateAxisTransfrom","coordBase","axisExtent","getExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","seriesModel","map","axesTypes","axisType","getReferringComponents","isCartesian2D","_config","__DEV__","_layout","getLayoutRect","axisHelper","Cartesian2D","Axis2D","CoordinateSystem","each","niceScaleExtent","gridProto","axisPointerEnabled","getRect","_rect","update","_updateScale","xAxis","scale","yAxis","resize","ignoreContainLabel","adjustAxes","axesList","isHorizontal","extent","gridRect","inverse","setExtent","getBoxLayoutParams","getWidth","getHeight","labelUnionRect","margin","position","getAxis","axisIndex","axesMapOnDim","name","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","dataToCoord","convertFromPixel","pointToData","coordToData","xAxisModel","yAxisModel","coordsList","coordinateSystem","indexOf","componentIndex","grid","containPoint","point","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","push","axesCount","left","right","top","bottom","eachComponent","addAxis","unionExtent","coordDimToDataDim","unionExtentFromData","Infinity","eachSeries","axesModels","getData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","getOtherAxis","create","grids","dimensions","register","518","__webpack_exports__","Object","defineProperty","arrs","test2","methods","test","_this","console","log","setTimeout","myChart","$echarts","document","getElementById","color","tooltip","trigger","axisPointer","containLabel","axisTick","alignWithLabel","series","barWidth","setOption","mounted","553","echarts","barLayoutGrid","registerLayout","curry","registerVisual","eachSeriesByType","setVisual","554","BaseBarSeries","dependencies","brushSelector","555","removeRect","dataIndex","animationModel","el","style","text","graphic","updateProps","shape","parent","remove","removeSector","r","r0","updateStyle","itemModel","layout","isPolar","getItemVisual","opacity","itemStyleModel","hoverStyle","getBarItemStyle","setShape","useStyle","defaults","fill","cursorStyle","getShallow","attr","labelPositionOutside","setLabel","setHoverStyle","getLineWidth","rawLayout","lineWidth","BAR_BORDER_WIDTH_QUERY","min","abs","_helper","Model","barItemStyle","extendChartView","render","coordinateSystemType","_render","group","dispose","noop","isHorizontalOrRadial","oldData","_data","isAnimationEnabled","diff","add","hasValue","getItemModel","getLayout","elementCreator","setItemGraphicEl","newIndex","oldIndex","getItemGraphicEl","execute","eachItemGraphicEl","removeAll","cartesian2d","isUpdate","Rect","rectShape","animateProperty","animateTarget","polar","isRadial","sector","Sector","sectorShape","startAngle","getItemLayout","fixedLineWidth","signX","signY","cx","cy","endAngle","556","SeriesModel","createListFromArray","getInitialData","getMarkerPosition","coordSys","pt","size","NaN","defaultOption","zlevel","z","legendHoverLink","barMinHeight","barMinAngle","itemStyle","557","makeStyleMapper","excludes","getBorderLineDash","lineDash","558","normalStyle","labelModel","hoverLabelModel","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getRawValue","isRectText","autoColor","fixPosition","textPosition","559","560","AxisBuilder","AxisView","cartesianAxisHelper","ifIgnoreOnTick","getInterval","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","axisPointerClass","payload","oldAxisGroup","_axisGroup","Group","axisBuilder","getGroup","labelInterval","groupTransition","superCall","_splitLine","isBlank","splitLineModel","lineStyleModel","lineColors","lineInterval","isArray","lineCount","ticksCoords","getTicksCoords","ticks","getTicks","showMinLabel","showMaxLabel","p1","p2","lineStyle","getLineStyle","tickCoord","colorIndex","Line","subPixelOptimizeLine","anid","x1","y1","x2","y2","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","count","areaInterval","areaStyle","getAreaStyle","561","extendComponentView","getItemStyle","z2","registerPreprocessor","562","show","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","axisLine","symbol","symbolSize","inside","axisLabel","fontSize","splitLine","splitArea","axisDefault","categoryAxis","boundaryGap","interval","valueAxis","splitNumber","timeAxis","max","logAxis","logBase","563","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AXIS_TYPES","mergeDefaultAndTheme","layoutMode","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","mergeAll","registerSubTypeDefaulter","564","Axis","coordExtent","call","constructor","getGlobalExtent","asc","ret","reverse","getLabelInterval","getLabel","clamp","inherits","565","dimAxisMapper","_axes","Cartesian","_dimList","getAxesByScale","scaleType","toLowerCase","filter","val","_dataCoordConvert","input","method","dimList","output","Array","566","axisX","axisY","contain","containData","567","backgroundColor","borderWidth","borderColor","568","getSeriesStackId","STACK_PREFIX","seriesIndex","getAxisKey","getLayoutOnAxis","opt","params","bandWidth","getBandWidth","axisKey","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","calBarWidthAndOffset","barSeries","parsePercent","barMaxWidth","barGap","barCategoryGap","seriesInfoList","columnsMap","seriesInfo","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","coordSysName","barGapPercent","autoWidth","column","stack","lastColumn","widthSum","seriesType","barWidthAndOffset","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","coordDims","coords","mapArray","setLayout","isNaN","p","n","sign","lastCoord","lastCoordOrigin","setItemLayout","_number","597","_vm","_h","$createElement","_c","_self","_l","arr","attrs","_v","_s","staticRenderFns"],"mappings":"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","file":"static/js/1.cdfb767fdbf5e02272ef.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 308:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(120)(\n  /* script */\n  __webpack_require__(518),\n  /* template */\n  __webpack_require__(597),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 513:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar ComponentModel = __webpack_require__(63);\n\nvar axisModelCreator = __webpack_require__(563);\n\nvar axisModelCommonMixin = __webpack_require__(292);\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 514:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(26);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(0);\n\nvar BoundingRect = __webpack_require__(18);\n\nvar _layout = __webpack_require__(64);\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = __webpack_require__(43);\n\nvar Cartesian2D = __webpack_require__(566);\n\nvar Axis2D = __webpack_require__(564);\n\nvar CoordinateSystem = __webpack_require__(122);\n\n__webpack_require__(567);\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 518:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n//\n\n__webpack_require__(553);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      arrs: [1, 2, 3],\n      test2: '222'\n    };\n  },\n\n  methods: {\n    test: function test(id) {\n      var _this = this;\n\n      console.log(id);\n      setTimeout(function () {\n        var myChart = _this.$echarts.init(document.getElementById('id' + id));\n        var option = {\n          color: ['#3398DB'],\n          tooltip: {\n            trigger: 'axis',\n            axisPointer: { // \n              type: 'shadow' // 'line' | 'shadow'\n            }\n          },\n          grid: {\n            left: '3%',\n            right: '4%',\n            bottom: '3%',\n            containLabel: true\n          },\n          xAxis: [{\n            type: 'category',\n            data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\n            axisTick: {\n              alignWithLabel: true\n            }\n          }],\n          yAxis: [{\n            type: 'value'\n          }],\n          series: [{\n            name: '',\n            type: 'bar',\n            barWidth: '60%',\n            data: [10, 52, 200, 334, 390, 330, 220]\n          }]\n        };\n        myChart.setOption(option);\n      }, 0);\n    }\n  },\n  mounted: function mounted() {}\n});\n\n/***/ }),\n\n/***/ 553:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar barLayoutGrid = __webpack_require__(568);\n\n__webpack_require__(514);\n\n__webpack_require__(554);\n\n__webpack_require__(555);\n\n__webpack_require__(561);\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n/***/ }),\n\n/***/ 554:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BaseBarSeries = __webpack_require__(556);\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 555:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(26);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(14);\n\nvar _helper = __webpack_require__(558);\n\nvar setLabel = _helper.setLabel;\n\nvar Model = __webpack_require__(22);\n\nvar barItemStyle = __webpack_require__(557);\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 556:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SeriesModel = __webpack_require__(293);\n\nvar createListFromArray = __webpack_require__(287);\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 0\n    barMinHeight: 0,\n    // 0\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // \n    // barWidth: null,\n    // 30%\n    // barGap: '30%',\n    // 20%\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: ''\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 557:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(81);\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 558:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(14);\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n/***/ }),\n\n/***/ 559:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(513);\n\n__webpack_require__(560);\n\n/***/ }),\n\n/***/ 560:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(14);\n\nvar AxisBuilder = __webpack_require__(288);\n\nvar AxisView = __webpack_require__(289);\n\nvar cartesianAxisHelper = __webpack_require__(290);\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n/***/ }),\n\n/***/ 561:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(14);\n\n__webpack_require__(514);\n\n__webpack_require__(559);\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n/***/ }),\n\n/***/ 562:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // \n  z: 0,\n  // \n  // \n  inverse: false,\n  // \n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // degree\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // \n  nameTextStyle: {},\n  // \n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // \n  axisLine: {\n    // show\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // lineStyle\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // \n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // \n  axisTick: {\n    // show\n    show: true,\n    // grid\n    inside: false,\n    // length\n    length: 5,\n    // lineStyle\n    lineStyle: {\n      width: 1\n    }\n  },\n  // axis.axisLabel\n  axisLabel: {\n    show: true,\n    // grid\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // TEXTSTYLE\n    fontSize: 12\n  },\n  // \n  splitLine: {\n    // show\n    show: true,\n    // lineStylelineStyle\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // \n  splitArea: {\n    // show\n    show: false,\n    // areaStyleareaStyle\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // \n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // \n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // \n  boundaryGap: [0, 0],\n  // ,  'dataMin' \n  // min: null,\n  //  'dataMax' \n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 0_min_max\n  // scale: false,\n  // 5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 563:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisDefault = __webpack_require__(562);\n\nvar ComponentModel = __webpack_require__(63);\n\nvar _layout = __webpack_require__(64);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 564:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Axis = __webpack_require__(291);\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 565:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 566:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Cartesian = __webpack_require__(565);\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 567:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(513);\n\nvar ComponentModel = __webpack_require__(63);\n\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 568:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar _number = __webpack_require__(10);\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 597:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', _vm._l((_vm.arrs), function(arr) {\n    return _c('div', {\n      style: ({\n        'width': '400px',\n        'height': '400px'\n      }),\n      attrs: {\n        \"id\": 'id' + arr\n      }\n    }, [_vm._v(\"\\n      \" + _vm._s(_vm.test(arr)) + \"\\n    \")])\n  }))\n},staticRenderFns: []}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/1.cdfb767fdbf5e02272ef.js","var Component = require(\"!../../../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Bar.vue\"),\n  /* template */\n  require(\"!!../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-2300605a\\\",\\\"hasScoped\\\":false}!../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./Bar.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/index/children/Echart/Bar.vue\n// module id = 308\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 513\n// module chunks = 1","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 514\n// module chunks = 1","<template>\n  <div>\n      <div v-for=\"arr in arrs\" :id=\"'id' + arr\" :style=\"{ 'width': '400px','height': '400px' }\">\n        {{ test(arr) }}\n      </div>\n  </div>\n</template>\n\n<script>\n  require('echarts/lib/chart/bar');\n  export default {\n    data() {\n      return {\n        arrs: [1,2,3],\n        test2: '222'\n      }\n    },\n    methods: {\n      test(id) {\n        console.log(id);\n        setTimeout(() => {\n          let myChart = this.$echarts.init(document.getElementById('id' + id));\n          let option = {\n            color: ['#3398DB'],\n            tooltip : {\n              trigger: 'axis',\n              axisPointer : {            // \n                type : 'shadow'        // 'line' | 'shadow'\n              }\n            },\n            grid: {\n              left: '3%',\n              right: '4%',\n              bottom: '3%',\n              containLabel: true\n            },\n            xAxis : [\n              {\n                type : 'category',\n                data : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\n                axisTick: {\n                  alignWithLabel: true\n                }\n              }\n            ],\n            yAxis : [\n              {\n                type : 'value'\n              }\n            ],\n            series : [\n              {\n                name:'',\n                type:'bar',\n                barWidth: '60%',\n                data:[10, 52, 200, 334, 390, 330, 220]\n              }\n            ]\n          };\n          myChart.setOption(option);\n        },0)\n      }\n    },\n    mounted() {\n\n    }\n  }\n</script>\n\n\n\n// WEBPACK FOOTER //\n// Bar.vue?aa86cfc0","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar barLayoutGrid = require(\"../layout/barGrid\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./bar/BarSeries\");\n\nrequire(\"./bar/BarView\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 553\n// module chunks = 1","var BaseBarSeries = require(\"./BaseBarSeries\");\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 554\n// module chunks = 1","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\nvar Model = require(\"../../model/Model\");\n\nvar barItemStyle = require(\"./barItemStyle\");\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 555\n// module chunks = 1","var SeriesModel = require(\"../../model/Series\");\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // \n    z: 2,\n    // \n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 0\n    barMinHeight: 0,\n    // 0\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // \n    // barWidth: null,\n    // 30%\n    // barGap: '30%',\n    // 20%\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: ''\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 556\n// module chunks = 1","var makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 557\n// module chunks = 1","var graphic = require(\"../../util/graphic\");\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 558\n// module chunks = 1","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 559\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 560\n// module chunks = 1","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/gridSimple.js\n// module id = 561\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // \n  z: 0,\n  // \n  // \n  inverse: false,\n  // \n  name: '',\n  // 'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // degree\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // \n  nameTextStyle: {},\n  // \n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // \n  axisLine: {\n    // show\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // lineStyle\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // \n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // \n  axisTick: {\n    // show\n    show: true,\n    // grid\n    inside: false,\n    // length\n    length: 5,\n    // lineStyle\n    lineStyle: {\n      width: 1\n    }\n  },\n  // axis.axisLabel\n  axisLabel: {\n    show: true,\n    // grid\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // TEXTSTYLE\n    fontSize: 12\n  },\n  // \n  splitLine: {\n    // show\n    show: true,\n    // lineStylelineStyle\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // \n  splitArea: {\n    // show\n    show: false,\n    // areaStyleareaStyle\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // \n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // \n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // \n  boundaryGap: [0, 0],\n  // ,  'dataMin' \n  // min: null,\n  //  'dataMax' \n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 0_min_max\n  // scale: false,\n  // 5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 562\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 563\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 564\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 565\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 566\n// module chunks = 1","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n// Grid \n//  Cartesian2D \nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 567\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 568\n// module chunks = 1","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', _vm._l((_vm.arrs), function(arr) {\n    return _c('div', {\n      style: ({\n        'width': '400px',\n        'height': '400px'\n      }),\n      attrs: {\n        \"id\": 'id' + arr\n      }\n    }, [_vm._v(\"\\n      \" + _vm._s(_vm.test(arr)) + \"\\n    \")])\n  }))\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-2300605a\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/pages/index/children/Echart/Bar.vue\n// module id = 597\n// module chunks = 1"],"sourceRoot":""}