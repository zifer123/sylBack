{"version":3,"sources":["webpack:///static/js/1.2152e79bfd7eacd0e032.js","webpack:///./src/pages/index/children/Echart/Bar.vue","webpack:///./~/echarts/lib/coord/cartesian/AxisModel.js","webpack:///./~/echarts/lib/coord/cartesian/Grid.js","webpack:///Bar.vue","webpack:///./~/echarts/lib/chart/bar.js","webpack:///./~/echarts/lib/chart/bar/BarSeries.js","webpack:///./~/echarts/lib/chart/bar/BarView.js","webpack:///./~/echarts/lib/chart/bar/BaseBarSeries.js","webpack:///./~/echarts/lib/chart/bar/barItemStyle.js","webpack:///./~/echarts/lib/chart/bar/helper.js","webpack:///./~/echarts/lib/component/axis.js","webpack:///./~/echarts/lib/component/axis/CartesianAxisView.js","webpack:///./~/echarts/lib/component/gridSimple.js","webpack:///./~/echarts/lib/coord/axisDefault.js","webpack:///./~/echarts/lib/coord/axisModelCreator.js","webpack:///./~/echarts/lib/coord/cartesian/Axis2D.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian.js","webpack:///./~/echarts/lib/coord/cartesian/Cartesian2D.js","webpack:///./~/echarts/lib/coord/cartesian/GridModel.js","webpack:///./~/echarts/lib/layout/barGrid.js","webpack:///./src/pages/index/children/Echart/Bar.vue?8dbe"],"names":["webpackJsonp","308","module","exports","__webpack_require__","Component","520","getAxisType","axisDim","option","type","data","zrUtil","ComponentModel","axisModelCreator","axisModelCommonMixin","AxisModel","extend","axis","init","superApply","this","arguments","resetRange","mergeOption","restoreData","getCoordSysModel","ecModel","queryComponents","mainType","index","gridIndex","id","gridId","merge","prototype","extraOption","offset","_default","521","isAxisUsedInTheGrid","axisModel","gridModel","rotateTextRect","textRect","rotate","rotateRadians","Math","PI","boundingBox","plain","beforeWidth","width","beforeHeight","height","afterWidth","cos","sin","afterHeight","BoundingRect","x","y","getLabelUnionRect","rect","model","labels","getFormattedLabels","axisLabelModel","getModel","step","labelCount","length","ceil","i","isLabelIgnored","unrotatedSingleRect","getTextRect","singleRect","get","union","Grid","api","_coordsMap","_coordsList","_axesMap","_axesList","_initCartesian","fixAxisOnZero","axesMap","otherAxisDim","axes","onZero","onZeroAxisIndex","otherAxis","canNotOnZeroToAxis","idx","hasOwnProperty","ifAxisCrossZero","updateAxisTransfrom","coordBase","axisExtent","getExtent","axisExtentSum","toGlobalCoord","dim","coord","toLocalCoord","findAxesModels","seriesModel","map","axesTypes","axisType","getReferringComponents","isCartesian2D","_config","__DEV__","_layout","getLayoutRect","axisHelper","Cartesian2D","Axis2D","CoordinateSystem","each","niceScaleExtent","gridProto","axisPointerEnabled","getRect","_rect","update","_updateScale","xAxis","scale","yAxis","resize","ignoreContainLabel","adjustAxes","axesList","isHorizontal","extent","gridRect","inverse","setExtent","getBoxLayoutParams","getWidth","getHeight","labelUnionRect","margin","position","getAxis","axisIndex","axesMapOnDim","name","getAxes","slice","getCartesian","xAxisIndex","yAxisIndex","key","isObject","coordList","getCartesians","convertToPixel","finder","value","target","_findConvertTarget","cartesian","dataToPoint","dataToCoord","convertFromPixel","pointToData","coordToData","xAxisModel","yAxisModel","coordsList","coordinateSystem","indexOf","componentIndex","grid","containPoint","point","createAxisCreator","axisPosition","axisPositionUsed","createScaleByModel","isCategory","onBand","push","axesCount","left","right","top","bottom","eachComponent","addAxis","unionExtent","coordDimToDataDim","unionExtentFromData","Infinity","eachSeries","axesModels","getData","getTooltipAxes","baseAxes","otherAxes","baseAxis","getBaseAxis","getOtherAxis","create","grids","dimensions","register","525","__webpack_exports__","Object","defineProperty","mounted","myChart","$echarts","document","getElementById","color","tooltip","trigger","axisPointer","containLabel","axisTick","alignWithLabel","series","barWidth","setOption","option2","title","text","subtext","legend","boundaryGap","560","echarts","barLayoutGrid","registerLayout","curry","registerVisual","eachSeriesByType","setVisual","561","BaseBarSeries","dependencies","brushSelector","562","removeRect","dataIndex","animationModel","el","style","graphic","updateProps","shape","parent","remove","removeSector","r","r0","updateStyle","itemModel","layout","isPolar","getItemVisual","opacity","itemStyleModel","hoverStyle","getBarItemStyle","setShape","useStyle","defaults","fill","cursorStyle","getShallow","attr","labelPositionOutside","setLabel","setHoverStyle","getLineWidth","rawLayout","lineWidth","BAR_BORDER_WIDTH_QUERY","min","abs","_helper","Model","barItemStyle","extendChartView","render","coordinateSystemType","_render","group","dispose","noop","isHorizontalOrRadial","oldData","_data","isAnimationEnabled","diff","add","hasValue","getItemModel","getLayout","elementCreator","setItemGraphicEl","newIndex","oldIndex","getItemGraphicEl","execute","eachItemGraphicEl","removeAll","cartesian2d","isUpdate","Rect","rectShape","animateProperty","animateTarget","polar","isRadial","sector","Sector","sectorShape","startAngle","getItemLayout","fixedLineWidth","signX","signY","cx","cy","endAngle","563","SeriesModel","createListFromArray","getInitialData","getMarkerPosition","coordSys","pt","size","NaN","defaultOption","zlevel","z","legendHoverLink","barMinHeight","barMinAngle","itemStyle","564","makeStyleMapper","excludes","getBorderLineDash","lineDash","565","normalStyle","labelModel","hoverLabelModel","setLabelStyle","labelFetcher","labelDataIndex","defaultText","getRawValue","isRectText","autoColor","fixPosition","textPosition","566","567","AxisBuilder","AxisView","cartesianAxisHelper","ifIgnoreOnTick","getInterval","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","axisPointerClass","payload","oldAxisGroup","_axisGroup","Group","axisBuilder","getGroup","labelInterval","groupTransition","superCall","_splitLine","isBlank","splitLineModel","lineStyleModel","lineColors","lineInterval","isArray","lineCount","ticksCoords","getTicksCoords","ticks","getTicks","showMinLabel","showMaxLabel","p1","p2","lineStyle","getLineStyle","tickCoord","colorIndex","Line","subPixelOptimizeLine","anid","x1","y1","x2","y2","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","prevX","prevY","count","areaInterval","areaStyle","getAreaStyle","568","extendComponentView","getItemStyle","z2","registerPreprocessor","569","show","nameLocation","nameRotate","nameTruncate","maxWidth","ellipsis","placeholder","nameTextStyle","nameGap","triggerEvent","axisLine","symbol","symbolSize","inside","axisLabel","fontSize","splitLine","splitArea","axisDefault","categoryAxis","interval","valueAxis","splitNumber","timeAxis","max","logAxis","logBase","570","axisName","BaseAxisModelClass","axisTypeDefaulter","extraDefaultOption","AXIS_TYPES","mergeDefaultAndTheme","layoutMode","inputPositionParams","getLayoutParams","themeModel","getTheme","getDefaultOption","mergeLayoutParam","mergeAll","registerSubTypeDefaulter","571","Axis","coordExtent","call","constructor","getGlobalExtent","asc","ret","reverse","getLabelInterval","getLabel","clamp","inherits","572","dimAxisMapper","_axes","Cartesian","_dimList","getAxesByScale","scaleType","toLowerCase","filter","val","_dataCoordConvert","input","method","dimList","output","Array","573","axisX","axisY","contain","containData","574","backgroundColor","borderWidth","borderColor","575","getSeriesStackId","STACK_PREFIX","seriesIndex","getAxisKey","getLayoutOnAxis","opt","params","bandWidth","getBandWidth","axisKey","stackId","widthAndOffsets","doCalBarWidthAndOffset","result","item","offsetCenter","calBarWidthAndOffset","barSeries","parsePercent","barMaxWidth","barGap","barCategoryGap","seriesInfoList","columnsMap","seriesInfo","columnsOnAxis","remainedWidth","autoWidthCount","categoryGap","gap","stacks","coordSysName","barGapPercent","autoWidth","column","stack","lastColumn","widthSum","seriesType","barWidthAndOffset","getSeriesByType","isSeriesFiltered","lastStackCoords","lastStackCoordsOrigin","columnLayoutInfo","columnOffset","columnWidth","valueAxisStart","coordDims","coords","mapArray","setLayout","isNaN","p","n","sign","lastCoord","lastCoordOrigin","setItemLayout","_number","604","_vm","_h","$createElement","_c","_self","attrs","_v","staticRenderFns"],"mappings":"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","file":"static/js/1.2152e79bfd7eacd0e032.js","sourcesContent":["webpackJsonp([1],{\n\n/***/ 308:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Component = __webpack_require__(119)(\n  /* script */\n  __webpack_require__(525),\n  /* template */\n  __webpack_require__(604),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n/***/ }),\n\n/***/ 520:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar ComponentModel = __webpack_require__(63);\n\nvar axisModelCreator = __webpack_require__(570);\n\nvar axisModelCommonMixin = __webpack_require__(292);\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 521:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(26);\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = __webpack_require__(0);\n\nvar BoundingRect = __webpack_require__(18);\n\nvar _layout = __webpack_require__(64);\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = __webpack_require__(41);\n\nvar Cartesian2D = __webpack_require__(573);\n\nvar Axis2D = __webpack_require__(571);\n\nvar CoordinateSystem = __webpack_require__(121);\n\n__webpack_require__(574);\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 525:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n//\n//\n//\n//\n//\n//\n//\n\n__webpack_require__(560);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  mounted: function mounted() {\n    var myChart = this.$echarts.init(document.getElementById('bar'));\n    var option = {\n      color: ['#3398DB'],\n      tooltip: {\n        trigger: 'axis',\n        axisPointer: { // 坐标轴指示器，坐标轴触发有效\n          type: 'shadow' // 默认为直线，可选为：'line' | 'shadow'\n        }\n      },\n      grid: {\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containLabel: true\n      },\n      xAxis: [{\n        type: 'category',\n        data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\n        axisTick: {\n          alignWithLabel: true\n        }\n      }],\n      yAxis: [{\n        type: 'value'\n      }],\n      series: [{\n        name: '直接访问',\n        type: 'bar',\n        barWidth: '60%',\n        data: [10, 52, 200, 334, 390, 330, 220]\n      }]\n    };\n    myChart.setOption(option);\n\n    var option2 = {\n      title: {\n        text: '世界人口总量',\n        subtext: '数据来自网络'\n      },\n      tooltip: {\n        trigger: 'axis',\n        axisPointer: {\n          type: 'shadow'\n        }\n      },\n      legend: {\n        data: ['2011年', '2012年']\n      },\n      grid: {\n        left: '3%',\n        right: '4%',\n        bottom: '3%',\n        containLabel: true\n      },\n      xAxis: {\n        type: 'value',\n        boundaryGap: [0, 0.01]\n      },\n      yAxis: {\n        type: 'category',\n        data: ['巴西', '印尼', '美国', '印度', '中国', '世界人口(万)']\n      },\n      series: [{\n        name: '2011年',\n        type: 'bar',\n        data: [18203, 23489, 29034, 104970, 131744, 630230]\n      }, {\n        name: '2012年',\n        type: 'bar',\n        data: [19325, 23438, 31000, 121594, 134141, 681807]\n      }]\n    };\n    var myChart2 = this.$echarts.init(document.getElementById('bar2'));\n    myChart2.setOption(option2);\n  }\n});\n\n/***/ }),\n\n/***/ 560:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar barLayoutGrid = __webpack_require__(575);\n\n__webpack_require__(521);\n\n__webpack_require__(561);\n\n__webpack_require__(562);\n\n__webpack_require__(568);\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n/***/ }),\n\n/***/ 561:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar BaseBarSeries = __webpack_require__(563);\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 562:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _config = __webpack_require__(26);\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(15);\n\nvar _helper = __webpack_require__(565);\n\nvar setLabel = _helper.setLabel;\n\nvar Model = __webpack_require__(22);\n\nvar barItemStyle = __webpack_require__(564);\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 563:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar SeriesModel = __webpack_require__(293);\n\nvar createListFromArray = __webpack_require__(287);\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 最小高度改为0\n    barMinHeight: 0,\n    // 最小角度为0，仅对极坐标系下的柱状图有效\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // 默认自适应\n    // barWidth: null,\n    // 柱间距离，默认为柱形宽度的30%，可设固定值\n    // barGap: '30%',\n    // 类目间柱形距离，默认为类目间距的20%，可设固定值\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: '各异'\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 564:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar makeStyleMapper = __webpack_require__(81);\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 565:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar graphic = __webpack_require__(15);\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n/***/ }),\n\n/***/ 566:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(520);\n\n__webpack_require__(567);\n\n/***/ }),\n\n/***/ 567:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(15);\n\nvar AxisBuilder = __webpack_require__(288);\n\nvar AxisView = __webpack_require__(289);\n\nvar cartesianAxisHelper = __webpack_require__(290);\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n/***/ }),\n\n/***/ 568:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar echarts = __webpack_require__(17);\n\nvar zrUtil = __webpack_require__(0);\n\nvar graphic = __webpack_require__(15);\n\n__webpack_require__(521);\n\n__webpack_require__(566);\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n/***/ }),\n\n/***/ 569:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // 一级层叠\n  z: 0,\n  // 二级层叠\n  // 反向坐标轴\n  inverse: false,\n  // 坐标轴名字，默认为空\n  name: '',\n  // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // 坐标轴名字旋转，degree。\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // 坐标轴文字样式，默认取全局样式\n  nameTextStyle: {},\n  // 文字与轴线距离\n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // 坐标轴线\n  axisLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // 坐标轴两端的箭头\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // 属性show控制显示与否，默认显示\n    show: true,\n    // 控制小标记是否在grid里\n    inside: false,\n    // 属性length控制线长\n    length: 5,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      width: 1\n    }\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    show: true,\n    // 控制文本标签是否在grid里\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n    fontSize: 12\n  },\n  // 分隔线\n  splitLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    // 属性lineStyle（详见lineStyle）控制线条样式\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // 分隔区域\n  splitArea: {\n    // 默认不显示，属性show控制显示与否\n    show: false,\n    // 属性areaStyle（详见areaStyle）控制区域样式\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // 类目起始和结束两端空白策略\n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // 数值起始和结束两端空白策略\n  boundaryGap: [0, 0],\n  // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n  // min: null,\n  // 最大值，设置成 'dataMax' 则从数据中计算最大值\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 脱离0值比例，放大聚焦到最终_min，_max区间\n  // scale: false,\n  // 分割段数，默认为5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 570:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar axisDefault = __webpack_require__(569);\n\nvar ComponentModel = __webpack_require__(63);\n\nvar _layout = __webpack_require__(64);\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 571:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Axis = __webpack_require__(291);\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 572:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 573:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar Cartesian = __webpack_require__(572);\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 574:\n/***/ (function(module, exports, __webpack_require__) {\n\n__webpack_require__(520);\n\nvar ComponentModel = __webpack_require__(63);\n\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 575:\n/***/ (function(module, exports, __webpack_require__) {\n\nvar zrUtil = __webpack_require__(0);\n\nvar _number = __webpack_require__(10);\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n/***/ }),\n\n/***/ 604:\n/***/ (function(module, exports) {\n\nmodule.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    style: ({\n      'width': '400px',\n      'height': '400px'\n    }),\n    attrs: {\n      \"id\": \"bar\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    style: ({\n      'width': '400px',\n      'height': '400px'\n    }),\n    attrs: {\n      \"id\": \"bar2\"\n    }\n  })])\n},staticRenderFns: []}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// static/js/1.2152e79bfd7eacd0e032.js","var Component = require(\"!../../../../../node_modules/vue-loader/lib/component-normalizer\")(\n  /* script */\n  require(\"!!babel-loader!../../../../../node_modules/vue-loader/lib/selector?type=script&index=0!./Bar.vue\"),\n  /* template */\n  require(\"!!../../../../../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-2300605a\\\",\\\"hasScoped\\\":false}!../../../../../node_modules/vue-loader/lib/selector?type=template&index=0!./Bar.vue\"),\n  /* styles */\n  null,\n  /* scopeId */\n  null,\n  /* moduleIdentifier (server only) */\n  null\n)\n\nmodule.exports = Component.exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/pages/index/children/Echart/Bar.vue\n// module id = 308\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\nvar axisModelCreator = require(\"../axisModelCreator\");\n\nvar axisModelCommonMixin = require(\"../axisModelCommonMixin\");\n\nvar AxisModel = ComponentModel.extend({\n  type: 'cartesian2dAxis',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Axis2D}\n   */\n  axis: null,\n\n  /**\n   * @override\n   */\n  init: function () {\n    AxisModel.superApply(this, 'init', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  mergeOption: function () {\n    AxisModel.superApply(this, 'mergeOption', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   */\n  restoreData: function () {\n    AxisModel.superApply(this, 'restoreData', arguments);\n    this.resetRange();\n  },\n\n  /**\n   * @override\n   * @return {module:echarts/model/Component}\n   */\n  getCoordSysModel: function () {\n    return this.ecModel.queryComponents({\n      mainType: 'grid',\n      index: this.option.gridIndex,\n      id: this.option.gridId\n    })[0];\n  }\n});\n\nfunction getAxisType(axisDim, option) {\n  // Default axis with data is category axis\n  return option.type || (option.data ? 'category' : 'value');\n}\n\nzrUtil.merge(AxisModel.prototype, axisModelCommonMixin);\nvar extraOption = {\n  // gridIndex: 0,\n  // gridId: '',\n  // Offset is for multiple axis on the same position\n  offset: 0\n};\naxisModelCreator('x', AxisModel, getAxisType, extraOption);\naxisModelCreator('y', AxisModel, getAxisType, extraOption);\nvar _default = AxisModel;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/AxisModel.js\n// module id = 520\n// module chunks = 1","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nvar _layout = require(\"../../util/layout\");\n\nvar getLayoutRect = _layout.getLayoutRect;\n\nvar axisHelper = require(\"../../coord/axisHelper\");\n\nvar Cartesian2D = require(\"./Cartesian2D\");\n\nvar Axis2D = require(\"./Axis2D\");\n\nvar CoordinateSystem = require(\"../../CoordinateSystem\");\n\nrequire(\"./GridModel\");\n\n/**\n * Grid is a region which contains at most 4 cartesian systems\n *\n * TODO Default cartesian\n */\n// Depends on GridModel, AxisModel, which performs preprocess.\nvar each = zrUtil.each;\nvar ifAxisCrossZero = axisHelper.ifAxisCrossZero;\nvar niceScaleExtent = axisHelper.niceScaleExtent;\n/**\n * Check if the axis is used in the specified grid\n * @inner\n */\n\nfunction isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {\n  return axisModel.getCoordSysModel() === gridModel;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n\nfunction getLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var labels = axisModel.getFormattedLabels();\n  var axisLabelModel = axisModel.getModel('axisLabel');\n  var rect;\n  var step = 1;\n  var labelCount = labels.length;\n\n  if (labelCount > 40) {\n    // Simple optimization for large amount of labels\n    step = Math.ceil(labelCount / 40);\n  }\n\n  for (var i = 0; i < labelCount; i += step) {\n    if (!axis.isLabelIgnored(i)) {\n      var unrotatedSingleRect = axisLabelModel.getTextRect(labels[i]);\n      var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n      rect ? rect.union(singleRect) : rect = singleRect;\n    }\n  }\n\n  return rect;\n}\n\nfunction Grid(gridModel, ecModel, api) {\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}\n   * @private\n   */\n  this._coordsMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Cartesian>}\n   * @private\n   */\n\n  this._coordsList = [];\n  /**\n   * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesMap = {};\n  /**\n   * @type {Array.<module:echarts/coord/cartesian/Axis2D>}\n   * @private\n   */\n\n  this._axesList = [];\n\n  this._initCartesian(gridModel, ecModel, api);\n\n  this.model = gridModel;\n}\n\nvar gridProto = Grid.prototype;\ngridProto.type = 'grid';\ngridProto.axisPointerEnabled = true;\n\ngridProto.getRect = function () {\n  return this._rect;\n};\n\ngridProto.update = function (ecModel, api) {\n  var axesMap = this._axesMap;\n\n  this._updateScale(ecModel, this.model);\n\n  each(axesMap.x, function (xAxis) {\n    niceScaleExtent(xAxis.scale, xAxis.model);\n  });\n  each(axesMap.y, function (yAxis) {\n    niceScaleExtent(yAxis.scale, yAxis.model);\n  });\n  each(axesMap.x, function (xAxis) {\n    fixAxisOnZero(axesMap, 'y', xAxis);\n  });\n  each(axesMap.y, function (yAxis) {\n    fixAxisOnZero(axesMap, 'x', yAxis);\n  }); // Resize again if containLabel is enabled\n  // FIXME It may cause getting wrong grid size in data processing stage\n\n  this.resize(this.model, api);\n};\n\nfunction fixAxisOnZero(axesMap, otherAxisDim, axis) {\n  // onZero can not be enabled in these two situations:\n  // 1. When any other axis is a category axis.\n  // 2. When no axis is cross 0 point.\n  var axes = axesMap[otherAxisDim];\n\n  if (!axis.onZero) {\n    return;\n  }\n\n  var onZeroAxisIndex = axis.onZeroAxisIndex; // If target axis is specified.\n\n  if (onZeroAxisIndex != null) {\n    var otherAxis = axes[onZeroAxisIndex];\n\n    if (otherAxis && canNotOnZeroToAxis(otherAxis)) {\n      axis.onZero = false;\n    }\n\n    return;\n  }\n\n  for (var idx in axes) {\n    if (axes.hasOwnProperty(idx)) {\n      var otherAxis = axes[idx];\n\n      if (otherAxis && !canNotOnZeroToAxis(otherAxis)) {\n        onZeroAxisIndex = +idx;\n        break;\n      }\n    }\n  }\n\n  if (onZeroAxisIndex == null) {\n    axis.onZero = false;\n  }\n\n  axis.onZeroAxisIndex = onZeroAxisIndex;\n}\n\nfunction canNotOnZeroToAxis(axis) {\n  return axis.type === 'category' || axis.type === 'time' || !ifAxisCrossZero(axis);\n}\n/**\n * Resize the grid\n * @param {module:echarts/coord/cartesian/GridModel} gridModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\ngridProto.resize = function (gridModel, api, ignoreContainLabel) {\n  var gridRect = getLayoutRect(gridModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n  this._rect = gridRect;\n  var axesList = this._axesList;\n  adjustAxes(); // Minus label size\n\n  if (!ignoreContainLabel && gridModel.get('containLabel')) {\n    each(axesList, function (axis) {\n      if (!axis.model.get('axisLabel.inside')) {\n        var labelUnionRect = getLabelUnionRect(axis);\n\n        if (labelUnionRect) {\n          var dim = axis.isHorizontal() ? 'height' : 'width';\n          var margin = axis.model.get('axisLabel.margin');\n          gridRect[dim] -= labelUnionRect[dim] + margin;\n\n          if (axis.position === 'top') {\n            gridRect.y += labelUnionRect.height + margin;\n          } else if (axis.position === 'left') {\n            gridRect.x += labelUnionRect.width + margin;\n          }\n        }\n      }\n    });\n    adjustAxes();\n  }\n\n  function adjustAxes() {\n    each(axesList, function (axis) {\n      var isHorizontal = axis.isHorizontal();\n      var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];\n      var idx = axis.inverse ? 1 : 0;\n      axis.setExtent(extent[idx], extent[1 - idx]);\n      updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);\n    });\n  }\n};\n/**\n * @param {string} axisType\n * @param {number} [axisIndex]\n */\n\n\ngridProto.getAxis = function (axisType, axisIndex) {\n  var axesMapOnDim = this._axesMap[axisType];\n\n  if (axesMapOnDim != null) {\n    if (axisIndex == null) {\n      // Find first axis\n      for (var name in axesMapOnDim) {\n        if (axesMapOnDim.hasOwnProperty(name)) {\n          return axesMapOnDim[name];\n        }\n      }\n    }\n\n    return axesMapOnDim[axisIndex];\n  }\n};\n/**\n * @return {Array.<module:echarts/coord/Axis>}\n */\n\n\ngridProto.getAxes = function () {\n  return this._axesList.slice();\n};\n/**\n * Usage:\n *      grid.getCartesian(xAxisIndex, yAxisIndex);\n *      grid.getCartesian(xAxisIndex);\n *      grid.getCartesian(null, yAxisIndex);\n *      grid.getCartesian({xAxisIndex: ..., yAxisIndex: ...});\n *\n * @param {number|Object} [xAxisIndex]\n * @param {number} [yAxisIndex]\n */\n\n\ngridProto.getCartesian = function (xAxisIndex, yAxisIndex) {\n  if (xAxisIndex != null && yAxisIndex != null) {\n    var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n    return this._coordsMap[key];\n  }\n\n  if (zrUtil.isObject(xAxisIndex)) {\n    yAxisIndex = xAxisIndex.yAxisIndex;\n    xAxisIndex = xAxisIndex.xAxisIndex;\n  } // When only xAxisIndex or yAxisIndex given, find its first cartesian.\n\n\n  for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {\n    if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {\n      return coordList[i];\n    }\n  }\n};\n\ngridProto.getCartesians = function () {\n  return this._coordsList.slice();\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertToPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null;\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.convertFromPixel = function (ecModel, finder, value) {\n  var target = this._findConvertTarget(ecModel, finder);\n\n  return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null;\n};\n/**\n * @inner\n */\n\n\ngridProto._findConvertTarget = function (ecModel, finder) {\n  var seriesModel = finder.seriesModel;\n  var xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis')[0];\n  var yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis')[0];\n  var gridModel = finder.gridModel;\n  var coordsList = this._coordsList;\n  var cartesian;\n  var axis;\n\n  if (seriesModel) {\n    cartesian = seriesModel.coordinateSystem;\n    zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);\n  } else if (xAxisModel && yAxisModel) {\n    cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  } else if (xAxisModel) {\n    axis = this.getAxis('x', xAxisModel.componentIndex);\n  } else if (yAxisModel) {\n    axis = this.getAxis('y', yAxisModel.componentIndex);\n  } // Lowest priority.\n  else if (gridModel) {\n      var grid = gridModel.coordinateSystem;\n\n      if (grid === this) {\n        cartesian = this._coordsList[0];\n      }\n    }\n\n  return {\n    cartesian: cartesian,\n    axis: axis\n  };\n};\n/**\n * @implements\n * see {module:echarts/CoodinateSystem}\n */\n\n\ngridProto.containPoint = function (point) {\n  var coord = this._coordsList[0];\n\n  if (coord) {\n    return coord.containPoint(point);\n  }\n};\n/**\n * Initialize cartesian coordinate systems\n * @private\n */\n\n\ngridProto._initCartesian = function (gridModel, ecModel, api) {\n  var axisPositionUsed = {\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  };\n  var axesMap = {\n    x: {},\n    y: {}\n  };\n  var axesCount = {\n    x: 0,\n    y: 0\n  }; /// Create axis\n\n  ecModel.eachComponent('xAxis', createAxisCreator('x'), this);\n  ecModel.eachComponent('yAxis', createAxisCreator('y'), this);\n\n  if (!axesCount.x || !axesCount.y) {\n    // Roll back when there no either x or y axis\n    this._axesMap = {};\n    this._axesList = [];\n    return;\n  }\n\n  this._axesMap = axesMap; /// Create cartesian2d\n\n  each(axesMap.x, function (xAxis, xAxisIndex) {\n    each(axesMap.y, function (yAxis, yAxisIndex) {\n      var key = 'x' + xAxisIndex + 'y' + yAxisIndex;\n      var cartesian = new Cartesian2D(key);\n      cartesian.grid = this;\n      cartesian.model = gridModel;\n      this._coordsMap[key] = cartesian;\n\n      this._coordsList.push(cartesian);\n\n      cartesian.addAxis(xAxis);\n      cartesian.addAxis(yAxis);\n    }, this);\n  }, this);\n\n  function createAxisCreator(axisType) {\n    return function (axisModel, idx) {\n      if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var axisPosition = axisModel.get('position');\n\n      if (axisType === 'x') {\n        // Fix position\n        if (axisPosition !== 'top' && axisPosition !== 'bottom') {\n          // Default bottom of X\n          axisPosition = 'bottom';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';\n          }\n        }\n      } else {\n        // Fix position\n        if (axisPosition !== 'left' && axisPosition !== 'right') {\n          // Default left of Y\n          axisPosition = 'left';\n\n          if (axisPositionUsed[axisPosition]) {\n            axisPosition = axisPosition === 'left' ? 'right' : 'left';\n          }\n        }\n      }\n\n      axisPositionUsed[axisPosition] = true;\n      var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition);\n      var isCategory = axis.type === 'category';\n      axis.onBand = isCategory && axisModel.get('boundaryGap');\n      axis.inverse = axisModel.get('inverse');\n      axis.onZero = axisModel.get('axisLine.onZero');\n      axis.onZeroAxisIndex = axisModel.get('axisLine.onZeroAxisIndex'); // Inject axis into axisModel\n\n      axisModel.axis = axis; // Inject axisModel into axis\n\n      axis.model = axisModel; // Inject grid info axis\n\n      axis.grid = this; // Index of axis, can be used as key\n\n      axis.index = idx;\n\n      this._axesList.push(axis);\n\n      axesMap[axisType][idx] = axis;\n      axesCount[axisType]++;\n    };\n  }\n};\n/**\n * Update cartesian properties from series\n * @param  {module:echarts/model/Option} option\n * @private\n */\n\n\ngridProto._updateScale = function (ecModel, gridModel) {\n  // Reset scale\n  zrUtil.each(this._axesList, function (axis) {\n    axis.scale.setExtent(Infinity, -Infinity);\n  });\n  ecModel.eachSeries(function (seriesModel) {\n    if (isCartesian2D(seriesModel)) {\n      var axesModels = findAxesModels(seriesModel, ecModel);\n      var xAxisModel = axesModels[0];\n      var yAxisModel = axesModels[1];\n\n      if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {\n        return;\n      }\n\n      var cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n      var data = seriesModel.getData();\n      var xAxis = cartesian.getAxis('x');\n      var yAxis = cartesian.getAxis('y');\n\n      if (data.type === 'list') {\n        unionExtent(data, xAxis, seriesModel);\n        unionExtent(data, yAxis, seriesModel);\n      }\n    }\n  }, this);\n\n  function unionExtent(data, axis, seriesModel) {\n    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {\n      axis.scale.unionExtentFromData(data, dim);\n    });\n  }\n};\n/**\n * @param {string} [dim] 'x' or 'y' or 'auto' or null/undefined\n * @return {Object} {baseAxes: [], otherAxes: []}\n */\n\n\ngridProto.getTooltipAxes = function (dim) {\n  var baseAxes = [];\n  var otherAxes = [];\n  each(this.getCartesians(), function (cartesian) {\n    var baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis();\n    var otherAxis = cartesian.getOtherAxis(baseAxis);\n    zrUtil.indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis);\n    zrUtil.indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis);\n  });\n  return {\n    baseAxes: baseAxes,\n    otherAxes: otherAxes\n  };\n};\n/**\n * @inner\n */\n\n\nfunction updateAxisTransfrom(axis, coordBase) {\n  var axisExtent = axis.getExtent();\n  var axisExtentSum = axisExtent[0] + axisExtent[1]; // Fast transform\n\n  axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {\n    return coord + coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n  axis.toLocalCoord = axis.dim === 'x' ? function (coord) {\n    return coord - coordBase;\n  } : function (coord) {\n    return axisExtentSum - coord + coordBase;\n  };\n}\n\nvar axesTypes = ['xAxis', 'yAxis'];\n/**\n * @inner\n */\n\nfunction findAxesModels(seriesModel, ecModel) {\n  return zrUtil.map(axesTypes, function (axisType) {\n    var axisModel = seriesModel.getReferringComponents(axisType)[0];\n    return axisModel;\n  });\n}\n/**\n * @inner\n */\n\n\nfunction isCartesian2D(seriesModel) {\n  return seriesModel.get('coordinateSystem') === 'cartesian2d';\n}\n\nGrid.create = function (ecModel, api) {\n  var grids = [];\n  ecModel.eachComponent('grid', function (gridModel, idx) {\n    var grid = new Grid(gridModel, ecModel, api);\n    grid.name = 'grid_' + idx; // dataSampling requires axis extent, so resize\n    // should be performed in create stage.\n\n    grid.resize(gridModel, api, true);\n    gridModel.coordinateSystem = grid;\n    grids.push(grid);\n  }); // Inject the coordinateSystems into seriesModel\n\n  ecModel.eachSeries(function (seriesModel) {\n    if (!isCartesian2D(seriesModel)) {\n      return;\n    }\n\n    var axesModels = findAxesModels(seriesModel, ecModel);\n    var xAxisModel = axesModels[0];\n    var yAxisModel = axesModels[1];\n    var gridModel = xAxisModel.getCoordSysModel();\n    var grid = gridModel.coordinateSystem;\n    seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);\n  });\n  return grids;\n}; // For deciding which dimensions to use when creating list data\n\n\nGrid.dimensions = Grid.prototype.dimensions = Cartesian2D.prototype.dimensions;\nCoordinateSystem.register('cartesian2d', Grid);\nvar _default = Grid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Grid.js\n// module id = 521\n// module chunks = 1","<template>\r\n  <div>\r\n    <div id=\"bar\" :style=\"{ 'width': '400px','height': '400px' }\"></div>\r\n    <div id=\"bar2\" :style=\"{ 'width': '400px','height': '400px' }\"></div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\n  require('echarts/lib/chart/bar');\r\n  export default {\r\n    mounted() {\r\n      let myChart = this.$echarts.init(document.getElementById('bar'));\r\n      let option = {\r\n        color: ['#3398DB'],\r\n        tooltip : {\r\n          trigger: 'axis',\r\n          axisPointer : {            // 坐标轴指示器，坐标轴触发有效\r\n            type : 'shadow'        // 默认为直线，可选为：'line' | 'shadow'\r\n          }\r\n        },\r\n        grid: {\r\n          left: '3%',\r\n          right: '4%',\r\n          bottom: '3%',\r\n          containLabel: true\r\n        },\r\n        xAxis : [\r\n          {\r\n            type : 'category',\r\n            data : ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],\r\n            axisTick: {\r\n              alignWithLabel: true\r\n            }\r\n          }\r\n        ],\r\n        yAxis : [\r\n          {\r\n            type : 'value'\r\n          }\r\n        ],\r\n        series : [\r\n          {\r\n            name:'直接访问',\r\n            type:'bar',\r\n            barWidth: '60%',\r\n            data:[10, 52, 200, 334, 390, 330, 220]\r\n          }\r\n        ]\r\n      };\r\n      myChart.setOption(option);\r\n\r\n\r\n      let option2 = {\r\n        title: {\r\n          text: '世界人口总量',\r\n          subtext: '数据来自网络'\r\n        },\r\n        tooltip: {\r\n          trigger: 'axis',\r\n          axisPointer: {\r\n            type: 'shadow'\r\n          }\r\n        },\r\n        legend: {\r\n          data: ['2011年', '2012年']\r\n        },\r\n        grid: {\r\n          left: '3%',\r\n          right: '4%',\r\n          bottom: '3%',\r\n          containLabel: true\r\n        },\r\n        xAxis: {\r\n          type: 'value',\r\n          boundaryGap: [0, 0.01]\r\n        },\r\n        yAxis: {\r\n          type: 'category',\r\n          data: ['巴西','印尼','美国','印度','中国','世界人口(万)']\r\n        },\r\n        series: [\r\n          {\r\n            name: '2011年',\r\n            type: 'bar',\r\n            data: [18203, 23489, 29034, 104970, 131744, 630230]\r\n          },\r\n          {\r\n            name: '2012年',\r\n            type: 'bar',\r\n            data: [19325, 23438, 31000, 121594, 134141, 681807]\r\n          }\r\n        ]\r\n      };\r\n      let myChart2 = this.$echarts.init(document.getElementById('bar2'));\r\n      myChart2.setOption(option2);\r\n    }\r\n  }\r\n</script>\r\n\n\n\n// WEBPACK FOOTER //\n// Bar.vue?d982cc72","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar barLayoutGrid = require(\"../layout/barGrid\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./bar/BarSeries\");\n\nrequire(\"./bar/BarView\");\n\nrequire(\"../component/gridSimple\");\n\n// In case developer forget to include grid component\necharts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar')); // Visual coding for legend\n\necharts.registerVisual(function (ecModel) {\n  ecModel.eachSeriesByType('bar', function (seriesModel) {\n    var data = seriesModel.getData();\n    data.setVisual('legendSymbol', 'roundRect');\n  });\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar.js\n// module id = 560\n// module chunks = 1","var BaseBarSeries = require(\"./BaseBarSeries\");\n\nvar _default = BaseBarSeries.extend({\n  type: 'series.bar',\n  dependencies: ['grid', 'polar'],\n  brushSelector: 'rect'\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarSeries.js\n// module id = 561\n// module chunks = 1","var _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar echarts = require(\"../../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar _helper = require(\"./helper\");\n\nvar setLabel = _helper.setLabel;\n\nvar Model = require(\"../../model/Model\");\n\nvar barItemStyle = require(\"./barItemStyle\");\n\nvar BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'normal', 'barBorderWidth']; // FIXME\n// Just for compatible with ec2.\n\nzrUtil.extend(Model.prototype, barItemStyle);\n\nvar _default = echarts.extendChartView({\n  type: 'bar',\n  render: function (seriesModel, ecModel, api) {\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._render(seriesModel, ecModel, api);\n    } else {}\n\n    return this.group;\n  },\n  dispose: zrUtil.noop,\n  _render: function (seriesModel, ecModel, api) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    data.diff(oldData).add(function (dataIndex) {\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      var el = elementCreator[coord.type](data, dataIndex, itemModel, layout, isHorizontalOrRadial, animationModel);\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).update(function (newIndex, oldIndex) {\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        return;\n      }\n\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (el) {\n        graphic.updateProps(el, {\n          shape: layout\n        }, animationModel, newIndex);\n      } else {\n        el = elementCreator[coord.type](data, newIndex, itemModel, layout, isHorizontalOrRadial, animationModel, true);\n      }\n\n      data.setItemGraphicEl(newIndex, el); // Add back\n\n      group.add(el);\n      updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n\n      if (coord.type === 'cartesian2d') {\n        el && removeRect(dataIndex, animationModel, el);\n      } else {\n        el && removeSector(dataIndex, animationModel, el);\n      }\n    }).execute();\n    this._data = data;\n  },\n  remove: function (ecModel, api) {\n    var group = this.group;\n    var data = this._data;\n\n    if (ecModel.get('animation')) {\n      if (data) {\n        data.eachItemGraphicEl(function (el) {\n          if (el.type === 'sector') {\n            removeSector(el.dataIndex, ecModel, el);\n          } else {\n            removeRect(el.dataIndex, ecModel, el);\n          }\n        });\n      }\n    } else {\n      group.removeAll();\n    }\n  }\n});\n\nvar elementCreator = {\n  cartesian2d: function (data, dataIndex, itemModel, layout, isHorizontal, animationModel, isUpdate) {\n    var rect = new graphic.Rect({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      var animateTarget = {};\n      rectShape[animateProperty] = 0;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](rect, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return rect;\n  },\n  polar: function (data, dataIndex, itemModel, layout, isRadial, animationModel, isUpdate) {\n    var sector = new graphic.Sector({\n      shape: zrUtil.extend({}, layout)\n    }); // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      graphic[isUpdate ? 'updateProps' : 'initProps'](sector, {\n        shape: animateTarget\n      }, animationModel, dataIndex);\n    }\n\n    return sector;\n  }\n};\n\nfunction removeRect(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      width: 0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nfunction removeSector(dataIndex, animationModel, el) {\n  // Not show text when animating\n  el.style.text = null;\n  graphic.updateProps(el, {\n    shape: {\n      r: el.shape.r0\n    }\n  }, animationModel, dataIndex, function () {\n    el.parent && el.parent.remove(el);\n  });\n}\n\nvar getLayout = {\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = getLineWidth(itemModel, layout); // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var color = data.getItemVisual(dataIndex, 'color');\n  var opacity = data.getItemVisual(dataIndex, 'opacity');\n  var itemStyleModel = itemModel.getModel('itemStyle.normal');\n  var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();\n\n  if (!isPolar) {\n    el.setShape('r', itemStyleModel.get('barBorderRadius') || 0);\n  }\n\n  el.useStyle(zrUtil.defaults({\n    fill: color,\n    opacity: opacity\n  }, itemStyleModel.getBarItemStyle()));\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n\n  if (!isPolar) {\n    setLabel(el.style, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside);\n  }\n\n  graphic.setHoverStyle(el, hoverStyle);\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  var lineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0;\n  return Math.min(lineWidth, Math.abs(rawLayout.width), Math.abs(rawLayout.height));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BarView.js\n// module id = 562\n// module chunks = 1","var SeriesModel = require(\"../../model/Series\");\n\nvar createListFromArray = require(\"../helper/createListFromArray\");\n\nvar _default = SeriesModel.extend({\n  type: 'series.__base_bar__',\n  getInitialData: function (option, ecModel) {\n    return createListFromArray(option.data, this, ecModel);\n  },\n  getMarkerPosition: function (value) {\n    var coordSys = this.coordinateSystem;\n\n    if (coordSys) {\n      // PENDING if clamp ?\n      var pt = coordSys.dataToPoint(value, true);\n      var data = this.getData();\n      var offset = data.getLayout('offset');\n      var size = data.getLayout('size');\n      var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;\n      pt[offsetIndex] += offset + size / 2;\n      return pt;\n    }\n\n    return [NaN, NaN];\n  },\n  defaultOption: {\n    zlevel: 0,\n    // 一级层叠\n    z: 2,\n    // 二级层叠\n    coordinateSystem: 'cartesian2d',\n    legendHoverLink: true,\n    // stack: null\n    // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // 最小高度改为0\n    barMinHeight: 0,\n    // 最小角度为0，仅对极坐标系下的柱状图有效\n    barMinAngle: 0,\n    // cursor: null,\n    // barMaxWidth: null,\n    // 默认自适应\n    // barWidth: null,\n    // 柱间距离，默认为柱形宽度的30%，可设固定值\n    // barGap: '30%',\n    // 类目间柱形距离，默认为类目间距的20%，可设固定值\n    // barCategoryGap: '20%',\n    // label: {\n    //     normal: {\n    //         show: false\n    //     }\n    // },\n    itemStyle: {// normal: {\n      // color: '各异'\n      // },\n      // emphasis: {}\n    }\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/BaseBarSeries.js\n// module id = 563\n// module chunks = 1","var makeStyleMapper = require(\"../../model/mixin/makeStyleMapper\");\n\nvar getBarItemStyle = makeStyleMapper([['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], // Compatitable with 2\n['stroke', 'barBorderColor'], ['lineWidth', 'barBorderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor']]);\nvar _default = {\n  getBarItemStyle: function (excludes) {\n    var style = getBarItemStyle(this, excludes);\n\n    if (this.getBorderLineDash) {\n      var lineDash = this.getBorderLineDash();\n      lineDash && (style.lineDash = lineDash);\n    }\n\n    return style;\n  }\n};\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/barItemStyle.js\n// module id = 564\n// module chunks = 1","var graphic = require(\"../../util/graphic\");\n\nfunction setLabel(normalStyle, hoverStyle, itemModel, color, seriesModel, dataIndex, labelPositionOutside) {\n  var labelModel = itemModel.getModel('label.normal');\n  var hoverLabelModel = itemModel.getModel('label.emphasis');\n  graphic.setLabelStyle(normalStyle, hoverStyle, labelModel, hoverLabelModel, {\n    labelFetcher: seriesModel,\n    labelDataIndex: dataIndex,\n    defaultText: seriesModel.getRawValue(dataIndex),\n    isRectText: true,\n    autoColor: color\n  });\n  fixPosition(normalStyle);\n  fixPosition(hoverStyle);\n}\n\nfunction fixPosition(style, labelPositionOutside) {\n  if (style.textPosition === 'outside') {\n    style.textPosition = labelPositionOutside;\n  }\n}\n\nexports.setLabel = setLabel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/chart/bar/helper.js\n// module id = 565\n// module chunks = 1","require(\"../coord/cartesian/AxisModel\");\n\nrequire(\"./axis/CartesianAxisView\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis.js\n// module id = 566\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"./cartesianAxisHelper\");\n\nvar ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;\nvar getInterval = AxisBuilder.getInterval;\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel, layout.labelInterval);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    var lineInterval = getInterval(splitLineModel, labelInterval);\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, lineInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n\n      this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({\n        anid: 'line_' + ticks[i],\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      })));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @param {number|Function} labelInterval\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel, labelInterval) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords();\n    var ticks = axis.scale.getTicks();\n    var prevX = axis.toGlobalCoord(ticksCoords[0]);\n    var prevY = axis.toGlobalCoord(ticksCoords[0]);\n    var count = 0;\n    var areaInterval = getInterval(splitAreaModel, labelInterval);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n    var showMaxLabel = axisModel.get('axisLabel.showMaxLabel');\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      if (ifIgnoreOnTick(axis, i, areaInterval, ticksCoords.length, showMinLabel, showMaxLabel)) {\n        continue;\n      }\n\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i]);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prevX;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n      } else {\n        x = gridRect.x;\n        y = prevY;\n        width = gridRect.width;\n        height = tickCoord - y;\n      }\n\n      var colorIndex = count++ % areaColors.length;\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: 'area_' + ticks[i],\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      prevX = x + width;\n      prevY = y + height;\n    }\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/axis/CartesianAxisView.js\n// module id = 567\n// module chunks = 1","var echarts = require(\"../echarts\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../util/graphic\");\n\nrequire(\"../coord/cartesian/Grid\");\n\nrequire(\"./axis\");\n\n// Grid view\necharts.extendComponentView({\n  type: 'grid',\n  render: function (gridModel, ecModel) {\n    this.group.removeAll();\n\n    if (gridModel.get('show')) {\n      this.group.add(new graphic.Rect({\n        shape: gridModel.coordinateSystem.getRect(),\n        style: zrUtil.defaults({\n          fill: gridModel.get('backgroundColor')\n        }, gridModel.getItemStyle()),\n        silent: true,\n        z2: -1\n      }));\n    }\n  }\n});\necharts.registerPreprocessor(function (option) {\n  // Only create grid when need\n  if (option.xAxis && option.yAxis && !option.grid) {\n    option.grid = {};\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/component/gridSimple.js\n// module id = 568\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar defaultOption = {\n  show: true,\n  zlevel: 0,\n  // 一级层叠\n  z: 0,\n  // 二级层叠\n  // 反向坐标轴\n  inverse: false,\n  // 坐标轴名字，默认为空\n  name: '',\n  // 坐标轴名字位置，支持'start' | 'middle' | 'end'\n  nameLocation: 'end',\n  // 坐标轴名字旋转，degree。\n  nameRotate: null,\n  // Adapt to axis rotate, when nameLocation is 'middle'.\n  nameTruncate: {\n    maxWidth: null,\n    ellipsis: '...',\n    placeholder: '.'\n  },\n  // 坐标轴文字样式，默认取全局样式\n  nameTextStyle: {},\n  // 文字与轴线距离\n  nameGap: 15,\n  silent: false,\n  // Default false to support tooltip.\n  triggerEvent: false,\n  // Default false to avoid legacy user event listener fail.\n  tooltip: {\n    show: false\n  },\n  axisPointer: {},\n  // 坐标轴线\n  axisLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    onZero: true,\n    onZeroAxisIndex: null,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      color: '#333',\n      width: 1,\n      type: 'solid'\n    },\n    // 坐标轴两端的箭头\n    symbol: ['none', 'none'],\n    symbolSize: [10, 15]\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // 属性show控制显示与否，默认显示\n    show: true,\n    // 控制小标记是否在grid里\n    inside: false,\n    // 属性length控制线长\n    length: 5,\n    // 属性lineStyle控制线条样式\n    lineStyle: {\n      width: 1\n    }\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    show: true,\n    // 控制文本标签是否在grid里\n    inside: false,\n    rotate: 0,\n    showMinLabel: null,\n    // true | false | null (auto)\n    showMaxLabel: null,\n    // true | false | null (auto)\n    margin: 8,\n    // formatter: null,\n    // 其余属性默认使用全局文本样式，详见TEXTSTYLE\n    fontSize: 12\n  },\n  // 分隔线\n  splitLine: {\n    // 默认显示，属性show控制显示与否\n    show: true,\n    // 属性lineStyle（详见lineStyle）控制线条样式\n    lineStyle: {\n      color: ['#ccc'],\n      width: 1,\n      type: 'solid'\n    }\n  },\n  // 分隔区域\n  splitArea: {\n    // 默认不显示，属性show控制显示与否\n    show: false,\n    // 属性areaStyle（详见areaStyle）控制区域样式\n    areaStyle: {\n      color: ['rgba(250,250,250,0.3)', 'rgba(200,200,200,0.3)']\n    }\n  }\n};\nvar axisDefault = {};\naxisDefault.categoryAxis = zrUtil.merge({\n  // 类目起始和结束两端空白策略\n  boundaryGap: true,\n  // splitArea: {\n  // show: false\n  // },\n  splitLine: {\n    show: false\n  },\n  // 坐标轴小标记\n  axisTick: {\n    // If tick is align with label when boundaryGap is true\n    alignWithLabel: false,\n    interval: 'auto'\n  },\n  // 坐标轴文本标签，详见axis.axisLabel\n  axisLabel: {\n    interval: 'auto'\n  }\n}, defaultOption);\naxisDefault.valueAxis = zrUtil.merge({\n  // 数值起始和结束两端空白策略\n  boundaryGap: [0, 0],\n  // 最小值, 设置成 'dataMin' 则从数据中计算最小值\n  // min: null,\n  // 最大值，设置成 'dataMax' 则从数据中计算最大值\n  // max: null,\n  // Readonly prop, specifies start value of the range when using data zoom.\n  // rangeStart: null\n  // Readonly prop, specifies end value of the range when using data zoom.\n  // rangeEnd: null\n  // 脱离0值比例，放大聚焦到最终_min，_max区间\n  // scale: false,\n  // 分割段数，默认为5\n  splitNumber: 5 // Minimum interval\n  // minInterval: null\n  // maxInterval: null\n\n}, defaultOption); // FIXME\n\naxisDefault.timeAxis = zrUtil.defaults({\n  scale: true,\n  min: 'dataMin',\n  max: 'dataMax'\n}, axisDefault.valueAxis);\naxisDefault.logAxis = zrUtil.defaults({\n  scale: true,\n  logBase: 10\n}, axisDefault.valueAxis);\nvar _default = axisDefault;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisDefault.js\n// module id = 569\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar axisDefault = require(\"./axisDefault\");\n\nvar ComponentModel = require(\"../model/Component\");\n\nvar _layout = require(\"../util/layout\");\n\nvar getLayoutParams = _layout.getLayoutParams;\nvar mergeLayoutParam = _layout.mergeLayoutParam;\n// FIXME axisType is fixed ?\nvar AXIS_TYPES = ['value', 'category', 'time', 'log'];\n/**\n * Generate sub axis model class\n * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'\n * @param {module:echarts/model/Component} BaseAxisModelClass\n * @param {Function} axisTypeDefaulter\n * @param {Object} [extraDefaultOption]\n */\n\nfunction _default(axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {\n  zrUtil.each(AXIS_TYPES, function (axisType) {\n    BaseAxisModelClass.extend({\n      type: axisName + 'Axis.' + axisType,\n      mergeDefaultAndTheme: function (option, ecModel) {\n        var layoutMode = this.layoutMode;\n        var inputPositionParams = layoutMode ? getLayoutParams(option) : {};\n        var themeModel = ecModel.getTheme();\n        zrUtil.merge(option, themeModel.get(axisType + 'Axis'));\n        zrUtil.merge(option, this.getDefaultOption());\n        option.type = axisTypeDefaulter(axisName, option);\n\n        if (layoutMode) {\n          mergeLayoutParam(option, inputPositionParams, layoutMode);\n        }\n      },\n      defaultOption: zrUtil.mergeAll([{}, axisDefault[axisType + 'Axis'], extraDefaultOption], true)\n    });\n  });\n  ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));\n}\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/axisModelCreator.js\n// module id = 570\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Axis = require(\"../Axis\");\n\n/**\n * Extend axis 2d\n * @constructor module:echarts/coord/cartesian/Axis2D\n * @extends {module:echarts/coord/cartesian/Axis}\n * @param {string} dim\n * @param {*} scale\n * @param {Array.<number>} coordExtent\n * @param {string} axisType\n * @param {string} position\n */\nvar Axis2D = function (dim, scale, coordExtent, axisType, position) {\n  Axis.call(this, dim, scale, coordExtent);\n  /**\n   * Axis type\n   *  - 'category'\n   *  - 'value'\n   *  - 'time'\n   *  - 'log'\n   * @type {string}\n   */\n\n  this.type = axisType || 'value';\n  /**\n   * Axis position\n   *  - 'top'\n   *  - 'bottom'\n   *  - 'left'\n   *  - 'right'\n   */\n\n  this.position = position || 'bottom';\n};\n\nAxis2D.prototype = {\n  constructor: Axis2D,\n\n  /**\n   * Index of axis, can be used as key\n   */\n  index: 0,\n\n  /**\n   * If axis is on the zero position of the other axis\n   * @type {boolean}\n   */\n  onZero: false,\n\n  /**\n   * Axis model\n   * @param {module:echarts/coord/cartesian/AxisModel}\n   */\n  model: null,\n  isHorizontal: function () {\n    var position = this.position;\n    return position === 'top' || position === 'bottom';\n  },\n\n  /**\n   * Each item cooresponds to this.getExtent(), which\n   * means globalExtent[0] may greater than globalExtent[1],\n   * unless `asc` is input.\n   *\n   * @param {boolean} [asc]\n   * @return {Array.<number>}\n   */\n  getGlobalExtent: function (asc) {\n    var ret = this.getExtent();\n    ret[0] = this.toGlobalCoord(ret[0]);\n    ret[1] = this.toGlobalCoord(ret[1]);\n    asc && ret[0] > ret[1] && ret.reverse();\n    return ret;\n  },\n  getOtherAxis: function () {\n    this.grid.getOtherAxis();\n  },\n\n  /**\n   * If label is ignored.\n   * Automatically used when axis is category and label can not be all shown\n   * @param  {number}  idx\n   * @return {boolean}\n   */\n  isLabelIgnored: function (idx) {\n    if (this.type === 'category') {\n      var labelInterval = this.getLabelInterval();\n      return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);\n    }\n  },\n\n  /**\n   * @override\n   */\n  pointToData: function (point, clamp) {\n    return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp);\n  },\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var localCoord = axis.toLocalCoord(80);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toLocalCoord: null,\n\n  /**\n   * Transform global coord to local coord,\n   * i.e. var globalCoord = axis.toLocalCoord(40);\n   * designate by module:echarts/coord/cartesian/Grid.\n   * @type {Function}\n   */\n  toGlobalCoord: null\n};\nzrUtil.inherits(Axis2D, Axis);\nvar _default = Axis2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Axis2D.js\n// module id = 571\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\n/**\n * Cartesian coordinate system\n * @module  echarts/coord/Cartesian\n *\n */\nfunction dimAxisMapper(dim) {\n  return this._axes[dim];\n}\n/**\n * @alias module:echarts/coord/Cartesian\n * @constructor\n */\n\n\nvar Cartesian = function (name) {\n  this._axes = {};\n  this._dimList = [];\n  /**\n   * @type {string}\n   */\n\n  this.name = name || '';\n};\n\nCartesian.prototype = {\n  constructor: Cartesian,\n  type: 'cartesian',\n\n  /**\n   * Get axis\n   * @param  {number|string} dim\n   * @return {module:echarts/coord/Cartesian~Axis}\n   */\n  getAxis: function (dim) {\n    return this._axes[dim];\n  },\n\n  /**\n   * Get axes list\n   * @return {Array.<module:echarts/coord/Cartesian~Axis>}\n   */\n  getAxes: function () {\n    return zrUtil.map(this._dimList, dimAxisMapper, this);\n  },\n\n  /**\n   * Get axes list by given scale type\n   */\n  getAxesByScale: function (scaleType) {\n    scaleType = scaleType.toLowerCase();\n    return zrUtil.filter(this.getAxes(), function (axis) {\n      return axis.scale.type === scaleType;\n    });\n  },\n\n  /**\n   * Add axis\n   * @param {module:echarts/coord/Cartesian.Axis}\n   */\n  addAxis: function (axis) {\n    var dim = axis.dim;\n    this._axes[dim] = axis;\n\n    this._dimList.push(dim);\n  },\n\n  /**\n   * Convert data to coord in nd space\n   * @param {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  dataToCoord: function (val) {\n    return this._dataCoordConvert(val, 'dataToCoord');\n  },\n\n  /**\n   * Convert coord in nd space to data\n   * @param  {Array.<number>|Object.<string, number>} val\n   * @return {Array.<number>|Object.<string, number>}\n   */\n  coordToData: function (val) {\n    return this._dataCoordConvert(val, 'coordToData');\n  },\n  _dataCoordConvert: function (input, method) {\n    var dimList = this._dimList;\n    var output = input instanceof Array ? [] : {};\n\n    for (var i = 0; i < dimList.length; i++) {\n      var dim = dimList[i];\n      var axis = this._axes[dim];\n      output[dim] = axis[method](input[dim]);\n    }\n\n    return output;\n  }\n};\nvar _default = Cartesian;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian.js\n// module id = 572\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar Cartesian = require(\"./Cartesian\");\n\nfunction Cartesian2D(name) {\n  Cartesian.call(this, name);\n}\n\nCartesian2D.prototype = {\n  constructor: Cartesian2D,\n  type: 'cartesian2d',\n\n  /**\n   * @type {Array.<string>}\n   * @readOnly\n   */\n  dimensions: ['x', 'y'],\n\n  /**\n   * Base axis will be used on stacking.\n   *\n   * @return {module:echarts/coord/cartesian/Axis2D}\n   */\n  getBaseAxis: function () {\n    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');\n  },\n\n  /**\n   * If contain point\n   * @param {Array.<number>} point\n   * @return {boolean}\n   */\n  containPoint: function (point) {\n    var axisX = this.getAxis('x');\n    var axisY = this.getAxis('y');\n    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));\n  },\n\n  /**\n   * If contain data\n   * @param {Array.<number>} data\n   * @return {boolean}\n   */\n  containData: function (data) {\n    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);\n  },\n\n  /**\n   * @param {Array.<number>} data\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  dataToPoint: function (data, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)), yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))];\n  },\n\n  /**\n   * @param {Array.<number>} point\n   * @param {boolean} [clamp=false]\n   * @return {Array.<number>}\n   */\n  pointToData: function (point, clamp) {\n    var xAxis = this.getAxis('x');\n    var yAxis = this.getAxis('y');\n    return [xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp), yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)];\n  },\n\n  /**\n   * Get other axis\n   * @param {module:echarts/coord/cartesian/Axis2D} axis\n   */\n  getOtherAxis: function (axis) {\n    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');\n  }\n};\nzrUtil.inherits(Cartesian2D, Cartesian);\nvar _default = Cartesian2D;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/Cartesian2D.js\n// module id = 573\n// module chunks = 1","require(\"./AxisModel\");\n\nvar ComponentModel = require(\"../../model/Component\");\n\n// Grid 是在有直角坐标系的时候必须要存在的\n// 所以这里也要被 Cartesian2D 依赖\nvar _default = ComponentModel.extend({\n  type: 'grid',\n  dependencies: ['xAxis', 'yAxis'],\n  layoutMode: 'box',\n\n  /**\n   * @type {module:echarts/coord/cartesian/Grid}\n   */\n  coordinateSystem: null,\n  defaultOption: {\n    show: false,\n    zlevel: 0,\n    z: 0,\n    left: '10%',\n    top: 60,\n    right: '10%',\n    bottom: 60,\n    // If grid size contain label\n    containLabel: false,\n    // width: {totalWidth} - left - right,\n    // height: {totalHeight} - top - bottom,\n    backgroundColor: 'rgba(0,0,0,0)',\n    borderWidth: 1,\n    borderColor: '#ccc'\n  }\n});\n\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/coord/cartesian/GridModel.js\n// module id = 574\n// module chunks = 1","var zrUtil = require(\"zrender/lib/core/util\");\n\nvar _number = require(\"../util/number\");\n\nvar parsePercent = _number.parsePercent;\nvar STACK_PREFIX = '__ec_stack_';\n\nfunction getSeriesStackId(seriesModel) {\n  return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex;\n}\n\nfunction getAxisKey(axis) {\n  return axis.dim + axis.index;\n}\n/**\n * @param {Object} opt\n * @param {module:echarts/coord/Axis} opt.axis Only support category axis currently.\n * @param {number} opt.count Positive interger.\n * @param {number} [opt.barWidth]\n * @param {number} [opt.barMaxWidth]\n * @param {number} [opt.barGap]\n * @param {number} [opt.barCategoryGap]\n * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.\n */\n\n\nfunction getLayoutOnAxis(opt, api) {\n  var params = [];\n  var baseAxis = opt.axis;\n  var axisKey = 'axis0';\n\n  if (baseAxis.type !== 'category') {\n    return;\n  }\n\n  var bandWidth = baseAxis.getBandWidth();\n\n  for (var i = 0; i < opt.count || 0; i++) {\n    params.push(zrUtil.defaults({\n      bandWidth: bandWidth,\n      axisKey: axisKey,\n      stackId: STACK_PREFIX + i\n    }, opt));\n  }\n\n  var widthAndOffsets = doCalBarWidthAndOffset(params, api);\n  var result = [];\n\n  for (var i = 0; i < opt.count; i++) {\n    var item = widthAndOffsets[axisKey][STACK_PREFIX + i];\n    item.offsetCenter = item.offset + item.width / 2;\n    result.push(item);\n  }\n\n  return result;\n}\n\nfunction calBarWidthAndOffset(barSeries, api) {\n  var seriesInfoList = zrUtil.map(barSeries, function (seriesModel) {\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var axisExtent = baseAxis.getExtent();\n    var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count();\n    var barWidth = parsePercent(seriesModel.get('barWidth'), bandWidth);\n    var barMaxWidth = parsePercent(seriesModel.get('barMaxWidth'), bandWidth);\n    var barGap = seriesModel.get('barGap');\n    var barCategoryGap = seriesModel.get('barCategoryGap');\n    return {\n      bandWidth: bandWidth,\n      barWidth: barWidth,\n      barMaxWidth: barMaxWidth,\n      barGap: barGap,\n      barCategoryGap: barCategoryGap,\n      axisKey: getAxisKey(baseAxis),\n      stackId: getSeriesStackId(seriesModel)\n    };\n  });\n  return doCalBarWidthAndOffset(seriesInfoList, api);\n}\n\nfunction doCalBarWidthAndOffset(seriesInfoList, api) {\n  // Columns info on each category axis. Key is cartesian name\n  var columnsMap = {};\n  zrUtil.each(seriesInfoList, function (seriesInfo, idx) {\n    var axisKey = seriesInfo.axisKey;\n    var bandWidth = seriesInfo.bandWidth;\n    var columnsOnAxis = columnsMap[axisKey] || {\n      bandWidth: bandWidth,\n      remainedWidth: bandWidth,\n      autoWidthCount: 0,\n      categoryGap: '20%',\n      gap: '30%',\n      stacks: {}\n    };\n    var stacks = columnsOnAxis.stacks;\n    columnsMap[axisKey] = columnsOnAxis;\n    var stackId = seriesInfo.stackId;\n\n    if (!stacks[stackId]) {\n      columnsOnAxis.autoWidthCount++;\n    }\n\n    stacks[stackId] = stacks[stackId] || {\n      width: 0,\n      maxWidth: 0\n    }; // Caution: In a single coordinate system, these barGrid attributes\n    // will be shared by series. Consider that they have default values,\n    // only the attributes set on the last series will work.\n    // Do not change this fact unless there will be a break change.\n    // TODO\n\n    var barWidth = seriesInfo.barWidth;\n\n    if (barWidth && !stacks[stackId].width) {\n      // See #6312, do not restrict width.\n      stacks[stackId].width = barWidth;\n      barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);\n      columnsOnAxis.remainedWidth -= barWidth;\n    }\n\n    var barMaxWidth = seriesInfo.barMaxWidth;\n    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);\n    var barGap = seriesInfo.barGap;\n    barGap != null && (columnsOnAxis.gap = barGap);\n    var barCategoryGap = seriesInfo.barCategoryGap;\n    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);\n  });\n  var result = {};\n  zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {\n    result[coordSysName] = {};\n    var stacks = columnsOnAxis.stacks;\n    var bandWidth = columnsOnAxis.bandWidth;\n    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);\n    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);\n    var remainedWidth = columnsOnAxis.remainedWidth;\n    var autoWidthCount = columnsOnAxis.autoWidthCount;\n    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0); // Find if any auto calculated bar exceeded maxBarWidth\n\n    zrUtil.each(stacks, function (column, stack) {\n      var maxWidth = column.maxWidth;\n\n      if (maxWidth && maxWidth < autoWidth) {\n        maxWidth = Math.min(maxWidth, remainedWidth);\n\n        if (column.width) {\n          maxWidth = Math.min(maxWidth, column.width);\n        }\n\n        remainedWidth -= maxWidth;\n        column.width = maxWidth;\n        autoWidthCount--;\n      }\n    }); // Recalculate width again\n\n    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);\n    autoWidth = Math.max(autoWidth, 0);\n    var widthSum = 0;\n    var lastColumn;\n    zrUtil.each(stacks, function (column, idx) {\n      if (!column.width) {\n        column.width = autoWidth;\n      }\n\n      lastColumn = column;\n      widthSum += column.width * (1 + barGapPercent);\n    });\n\n    if (lastColumn) {\n      widthSum -= lastColumn.width * barGapPercent;\n    }\n\n    var offset = -widthSum / 2;\n    zrUtil.each(stacks, function (column, stackId) {\n      result[coordSysName][stackId] = result[coordSysName][stackId] || {\n        offset: offset,\n        width: column.width\n      };\n      offset += column.width * (1 + barGapPercent);\n    });\n  });\n  return result;\n}\n/**\n * @param {string} seriesType\n * @param {module:echarts/model/Global} ecModel\n * @param {module:echarts/ExtensionAPI} api\n */\n\n\nfunction barLayoutGrid(seriesType, ecModel, api) {\n  var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {\n    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';\n  }));\n  var lastStackCoords = {};\n  var lastStackCoordsOrigin = {};\n  ecModel.eachSeriesByType(seriesType, function (seriesModel) {\n    // Check series coordinate, do layout for cartesian2d only\n    if (seriesModel.coordinateSystem.type !== 'cartesian2d') {\n      return;\n    }\n\n    var data = seriesModel.getData();\n    var cartesian = seriesModel.coordinateSystem;\n    var baseAxis = cartesian.getBaseAxis();\n    var stackId = getSeriesStackId(seriesModel);\n    var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];\n    var columnOffset = columnLayoutInfo.offset;\n    var columnWidth = columnLayoutInfo.width;\n    var valueAxis = cartesian.getOtherAxis(baseAxis);\n    var barMinHeight = seriesModel.get('barMinHeight') || 0;\n    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];\n    var coordDims = [seriesModel.coordDimToDataDim('x')[0], seriesModel.coordDimToDataDim('y')[0]];\n    var coords = data.mapArray(coordDims, function (x, y) {\n      return cartesian.dataToPoint([x, y]);\n    }, true);\n    lastStackCoords[stackId] = lastStackCoords[stackId] || [];\n    lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243\n\n    data.setLayout({\n      offset: columnOffset,\n      size: columnWidth\n    });\n    data.each(seriesModel.coordDimToDataDim(valueAxis.dim)[0], function (value, idx) {\n      if (isNaN(value)) {\n        return;\n      }\n\n      if (!lastStackCoords[stackId][idx]) {\n        lastStackCoords[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n        lastStackCoordsOrigin[stackId][idx] = {\n          p: valueAxisStart,\n          // Positive stack\n          n: valueAxisStart // Negative stack\n\n        };\n      }\n\n      var sign = value >= 0 ? 'p' : 'n';\n      var coord = coords[idx];\n      var lastCoord = lastStackCoords[stackId][idx][sign];\n      var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (valueAxis.isHorizontal()) {\n        x = lastCoord;\n        y = coord[1] + columnOffset;\n        width = coord[0] - lastCoordOrigin;\n        height = columnWidth;\n        lastStackCoordsOrigin[stackId][idx][sign] += width;\n\n        if (Math.abs(width) < barMinHeight) {\n          width = (width < 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += width;\n      } else {\n        x = coord[0] + columnOffset;\n        y = lastCoord;\n        width = columnWidth;\n        height = coord[1] - lastCoordOrigin;\n        lastStackCoordsOrigin[stackId][idx][sign] += height;\n\n        if (Math.abs(height) < barMinHeight) {\n          // Include zero to has a positive bar\n          height = (height <= 0 ? -1 : 1) * barMinHeight;\n        }\n\n        lastStackCoords[stackId][idx][sign] += height;\n      }\n\n      data.setItemLayout(idx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n    }, true);\n  }, this);\n}\n\nbarLayoutGrid.getLayoutOnAxis = getLayoutOnAxis;\nvar _default = barLayoutGrid;\nmodule.exports = _default;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/echarts/lib/layout/barGrid.js\n// module id = 575\n// module chunks = 1","module.exports={render:function (){var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;\n  return _c('div', [_c('div', {\n    style: ({\n      'width': '400px',\n      'height': '400px'\n    }),\n    attrs: {\n      \"id\": \"bar\"\n    }\n  }), _vm._v(\" \"), _c('div', {\n    style: ({\n      'width': '400px',\n      'height': '400px'\n    }),\n    attrs: {\n      \"id\": \"bar2\"\n    }\n  })])\n},staticRenderFns: []}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vue-loader/lib/template-compiler?{\"id\":\"data-v-2300605a\",\"hasScoped\":false}!./~/vue-loader/lib/selector.js?type=template&index=0!./src/pages/index/children/Echart/Bar.vue\n// module id = 604\n// module chunks = 1"],"sourceRoot":""}